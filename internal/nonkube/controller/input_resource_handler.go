package controller

import (
	"fmt"
	"log/slog"
	"os"
	"strings"
	"sync"

	"github.com/skupperproject/skupper/api/types"
	cmd "github.com/skupperproject/skupper/internal/cmd/skupper/common"
	"github.com/skupperproject/skupper/internal/nonkube/bootstrap"
	"github.com/skupperproject/skupper/internal/nonkube/common"
	common2 "github.com/skupperproject/skupper/internal/nonkube/common"
	"github.com/skupperproject/skupper/internal/nonkube/compat"
	"github.com/skupperproject/skupper/internal/utils"
	"github.com/skupperproject/skupper/pkg/nonkube/api"
)

// This feature is responsible for handling the creation of input resources and
// execute the start/reload of the site configuration automatically.
type InputResourceHandler struct {
	logger            *slog.Logger
	namespace         string
	inputPath         string
	Bootstrap         func(config *bootstrap.Config) (*api.SiteState, error)
	PostExec          func(config *bootstrap.Config, siteState *api.SiteState)
	TearDown          func(namespace string) error
	ConfigBootstrap   bootstrap.Config
	lock              sync.Mutex
	siteStateRenderer *compat.SiteStateRenderer
	siteStateLoader   api.SiteStateLoader
}

type Bootstrap func(config *bootstrap.Config) (*api.SiteState, error)
type PostBootstrap func(config *bootstrap.Config, siteState *api.SiteState)
type TearDown func(namespace string) error

func NewInputResourceHandler(namespace string, inputPath string, bs Bootstrap, pbs PostBootstrap, td TearDown) *InputResourceHandler {

	systemReloadType := utils.DefaultStr(os.Getenv(types.ENV_SYSTEM_AUTO_RELOAD),
		types.SystemReloadTypeManual)

	if systemReloadType == types.SystemReloadTypeManual {
		slog.Default().Debug("Automatic reloading is not configured.")
		return nil
	}

	handler := &InputResourceHandler{
		namespace: namespace,
		inputPath: inputPath,
	}

	handler.logger = slog.Default().With("component", "input.resource.handler", "namespace", namespace)

	handler.Bootstrap = bs
	handler.PostExec = pbs
	handler.TearDown = td

	var binary string

	platform := types.Platform(utils.DefaultStr(os.Getenv("CONTAINER_ENGINE"),
		string(types.PlatformPodman)))

	// TODO: add support for linux platform
	switch cmd.Platform(platform) {
	case cmd.PlatformDocker:
		binary = "docker"
	case cmd.PlatformPodman:
		binary = "podman"
	case cmd.PlatformLinux:
		handler.logger.Error("Linux platform is not supported yet")
		return nil
	default:
		handler.logger.Error("This platform value is not supported: ", slog.String("platform", string(platform)))
		return nil
	}

	handler.ConfigBootstrap = bootstrap.Config{
		Namespace: namespace,
		InputPath: inputPath,
		Platform:  platform,
		Binary:    binary,
	}

	handler.siteStateRenderer = &compat.SiteStateRenderer{
		Platform: platform,
	}

	handler.siteStateLoader = &common.FileSystemSiteStateLoader{
		Path:   api.GetInternalOutputPath(namespace, api.InputSiteStatePath),
		Bundle: false,
	}

	return handler
}

func (h *InputResourceHandler) OnCreate(name string) {
	h.lock.Lock()
	defer h.lock.Unlock()

	h.logger.Info(fmt.Sprintf("Resource has been created: %s", name))
	err := h.processInputFile()
	if err != nil {
		h.logger.Error(err.Error())
	}
}

// This function does not need to be implemented, given that when a file is updated,
// the event OnCreate is triggered anyway. Having it implemented would cause
// the resources to be reloaded multiple times, stopping and starting a router pod.
// (issue: the router pod is still active while going to be deleted, and the controller
// tries to create a new router pod, failing on this)
func (h *InputResourceHandler) OnUpdate(name string) {}
func (h *InputResourceHandler) OnRemove(name string) {
	h.lock.Lock()
	defer h.lock.Unlock()

	h.logger.Info(fmt.Sprintf("Resource has been deleted: %s", name))

	siteStateLoader := &common2.FileSystemSiteStateLoader{
		Path:   h.ConfigBootstrap.InputPath,
		Bundle: h.ConfigBootstrap.IsBundle,
	}
	siteState, err := siteStateLoader.Load()

	//If there is no site configured, the namespace needs to be removed
	if err != nil || siteState == nil || siteState.Site == nil {
		err = h.tearDownNamespace()
		if err != nil {
			h.logger.Error(err.Error())
		}
		return
	}

	err = h.processInputFile()
	if err != nil {
		h.logger.Error(err.Error())
	}
}
func (h *InputResourceHandler) Filter(name string) bool {
	return strings.HasSuffix(name, ".json") || strings.HasSuffix(name, ".yaml") || strings.HasSuffix(name, ".yml")
}

func (h *InputResourceHandler) OnBasePathAdded(basePath string) {}

func (h *InputResourceHandler) processInputFile() error {
	_, err := os.Stat(api.GetInternalOutputPath(h.namespace, api.RuntimeSiteStatePath))
	if err == nil {
		//a site has already been created, no need to bootstrap
		siteState, err := h.siteStateLoader.Load()
		if !siteState.IsBundle() {
			if err != nil {
				return fmt.Errorf("Failed to load site: %s", err)
			}
			h.siteStateRenderer.Refresh(siteState)
		}

	} else {
		siteState, err := h.Bootstrap(&h.ConfigBootstrap)
		if err != nil {
			return fmt.Errorf("Failed to bootstrap: %s", err)
		}
		h.PostExec(&h.ConfigBootstrap, siteState)
	}

	return nil
}

func (h *InputResourceHandler) tearDownNamespace() error {
	h.logger.Info("No site configured, tearing down namespace")
	err := h.TearDown(h.namespace)
	if err != nil {
		return err
	}

	return nil
}
